// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKS_PACKETS_H_
#define FLATBUFFERS_GENERATED_NETWORKS_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "BaseStructures_generated.h"
#include "Enums_generated.h"

namespace Packets {

struct ProtocolVersionSC;
struct ProtocolVersionSCBuilder;

struct NotifyIdSC;
struct NotifyIdSCBuilder;

struct PlayerEnterInLobbySC;
struct PlayerEnterInLobbySCBuilder;

struct PlayerReadyInLobbySC;
struct PlayerReadyInLobbySCBuilder;

struct PlayerCancelReadySC;
struct PlayerCancelReadySCBuilder;

struct RejectSelectionRoleSC;
struct RejectSelectionRoleSCBuilder;

struct ConfirmSelectionRoleSC;
struct ConfirmSelectionRoleSCBuilder;

struct PlayerChangeRoleSC;
struct PlayerChangeRoleSCBuilder;

struct StartSceneTransitionSC;
struct StartSceneTransitionSCBuilder;

struct CancelSceneTransitionSC;
struct CancelSceneTransitionSCBuilder;

struct ChangeSceneSC;
struct ChangeSceneSCBuilder;

struct GameEndSC;
struct GameEndSCBuilder;

struct PlayerExitSC;
struct PlayerExitSCBuilder;

struct PlayerExitCS;
struct PlayerExitCSBuilder;

struct PlayerEnterInGame;
struct PlayerEnterInGameBuilder;

struct PlayerReadyInLobbyCS;
struct PlayerReadyInLobbyCSBuilder;

struct PlayerCancelReadyCS;
struct PlayerCancelReadyCSBuilder;

struct PlayerEnterInLobbyCS;
struct PlayerEnterInLobbyCSBuilder;

struct PlayerInputCS;
struct PlayerInputCSBuilder;

struct PlayerLookCS;
struct PlayerLookCSBuilder;

struct PlayerSelectRoleCS;
struct PlayerSelectRoleCSBuilder;

struct PacketLatencyCS;
struct PacketLatencyCSBuilder;

struct PacketLatencySC;
struct PacketLatencySCBuilder;

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
struct ProtocolVersionSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProtocolVersionSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAJOR = 4,
    VT_MINOR = 6
  };
  uint8_t major() const {
    return GetField<uint8_t>(VT_MAJOR, 2);
  }
  uint8_t minor() const {
    return GetField<uint8_t>(VT_MINOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_MINOR, 1) &&
           verifier.EndTable();
  }
};

struct ProtocolVersionSCBuilder {
  typedef ProtocolVersionSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_major(uint8_t major) {
    fbb_.AddElement<uint8_t>(ProtocolVersionSC::VT_MAJOR, major, 2);
  }
  void add_minor(uint8_t minor) {
    fbb_.AddElement<uint8_t>(ProtocolVersionSC::VT_MINOR, minor, 0);
  }
  explicit ProtocolVersionSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProtocolVersionSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProtocolVersionSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProtocolVersionSC> CreateProtocolVersionSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t major = 2,
    uint8_t minor = 0) {
  ProtocolVersionSCBuilder builder_(_fbb);
  builder_.add_minor(minor);
  builder_.add_major(major);
  return builder_.Finish();
}

struct NotifyIdSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyIdSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           verifier.EndTable();
  }
};

struct NotifyIdSCBuilder {
  typedef NotifyIdSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(NotifyIdSC::VT_PLAYERID, playerId, 0);
  }
  explicit NotifyIdSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyIdSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyIdSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyIdSC> CreateNotifyIdSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0) {
  NotifyIdSCBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

struct PlayerEnterInLobbySC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerEnterInLobbySCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4,
    VT_PLAYERSLOT = 6,
    VT_ROLE = 8,
    VT_NAME = 10
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  uint8_t playerSlot() const {
    return GetField<uint8_t>(VT_PLAYERSLOT, 0);
  }
  Packets::PlayerRole role() const {
    return static_cast<Packets::PlayerRole>(GetField<uint8_t>(VT_ROLE, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERSLOT, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PlayerEnterInLobbySCBuilder {
  typedef PlayerEnterInLobbySC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerEnterInLobbySC::VT_PLAYERID, playerId, 0);
  }
  void add_playerSlot(uint8_t playerSlot) {
    fbb_.AddElement<uint8_t>(PlayerEnterInLobbySC::VT_PLAYERSLOT, playerSlot, 0);
  }
  void add_role(Packets::PlayerRole role) {
    fbb_.AddElement<uint8_t>(PlayerEnterInLobbySC::VT_ROLE, static_cast<uint8_t>(role), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PlayerEnterInLobbySC::VT_NAME, name);
  }
  explicit PlayerEnterInLobbySCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerEnterInLobbySC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerEnterInLobbySC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerEnterInLobbySC> CreatePlayerEnterInLobbySC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    uint8_t playerSlot = 0,
    Packets::PlayerRole role = Packets::PlayerRole_NONE,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  PlayerEnterInLobbySCBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_role(role);
  builder_.add_playerSlot(playerSlot);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerEnterInLobbySC> CreatePlayerEnterInLobbySCDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    uint8_t playerSlot = 0,
    Packets::PlayerRole role = Packets::PlayerRole_NONE,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Packets::CreatePlayerEnterInLobbySC(
      _fbb,
      playerId,
      playerSlot,
      role,
      name__);
}

struct PlayerReadyInLobbySC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerReadyInLobbySCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           verifier.EndTable();
  }
};

struct PlayerReadyInLobbySCBuilder {
  typedef PlayerReadyInLobbySC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerReadyInLobbySC::VT_PLAYERID, playerId, 0);
  }
  explicit PlayerReadyInLobbySCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerReadyInLobbySC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerReadyInLobbySC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerReadyInLobbySC> CreatePlayerReadyInLobbySC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0) {
  PlayerReadyInLobbySCBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

struct PlayerCancelReadySC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerCancelReadySCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           verifier.EndTable();
  }
};

struct PlayerCancelReadySCBuilder {
  typedef PlayerCancelReadySC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerCancelReadySC::VT_PLAYERID, playerId, 0);
  }
  explicit PlayerCancelReadySCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerCancelReadySC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerCancelReadySC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerCancelReadySC> CreatePlayerCancelReadySC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0) {
  PlayerCancelReadySCBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

struct RejectSelectionRoleSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RejectSelectionRoleSCBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RejectSelectionRoleSCBuilder {
  typedef RejectSelectionRoleSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RejectSelectionRoleSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RejectSelectionRoleSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RejectSelectionRoleSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RejectSelectionRoleSC> CreateRejectSelectionRoleSC(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RejectSelectionRoleSCBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ConfirmSelectionRoleSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfirmSelectionRoleSCBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ConfirmSelectionRoleSCBuilder {
  typedef ConfirmSelectionRoleSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ConfirmSelectionRoleSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfirmSelectionRoleSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfirmSelectionRoleSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfirmSelectionRoleSC> CreateConfirmSelectionRoleSC(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ConfirmSelectionRoleSCBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerChangeRoleSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerChangeRoleSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4,
    VT_ROLE = 6
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  Packets::PlayerRole role() const {
    return static_cast<Packets::PlayerRole>(GetField<uint8_t>(VT_ROLE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           verifier.EndTable();
  }
};

struct PlayerChangeRoleSCBuilder {
  typedef PlayerChangeRoleSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerChangeRoleSC::VT_PLAYERID, playerId, 0);
  }
  void add_role(Packets::PlayerRole role) {
    fbb_.AddElement<uint8_t>(PlayerChangeRoleSC::VT_ROLE, static_cast<uint8_t>(role), 0);
  }
  explicit PlayerChangeRoleSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerChangeRoleSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerChangeRoleSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerChangeRoleSC> CreatePlayerChangeRoleSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    Packets::PlayerRole role = Packets::PlayerRole_NONE) {
  PlayerChangeRoleSCBuilder builder_(_fbb);
  builder_.add_role(role);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

struct StartSceneTransitionSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartSceneTransitionSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSITIONDELAY = 4
  };
  float transitionDelay() const {
    return GetField<float>(VT_TRANSITIONDELAY, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRANSITIONDELAY, 4) &&
           verifier.EndTable();
  }
};

struct StartSceneTransitionSCBuilder {
  typedef StartSceneTransitionSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_transitionDelay(float transitionDelay) {
    fbb_.AddElement<float>(StartSceneTransitionSC::VT_TRANSITIONDELAY, transitionDelay, 0.0f);
  }
  explicit StartSceneTransitionSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartSceneTransitionSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartSceneTransitionSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartSceneTransitionSC> CreateStartSceneTransitionSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float transitionDelay = 0.0f) {
  StartSceneTransitionSCBuilder builder_(_fbb);
  builder_.add_transitionDelay(transitionDelay);
  return builder_.Finish();
}

struct CancelSceneTransitionSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CancelSceneTransitionSCBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CancelSceneTransitionSCBuilder {
  typedef CancelSceneTransitionSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CancelSceneTransitionSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CancelSceneTransitionSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CancelSceneTransitionSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CancelSceneTransitionSC> CreateCancelSceneTransitionSC(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CancelSceneTransitionSCBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ChangeSceneSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChangeSceneSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE = 4
  };
  Packets::GameStage stage() const {
    return static_cast<Packets::GameStage>(GetField<uint8_t>(VT_STAGE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STAGE, 1) &&
           verifier.EndTable();
  }
};

struct ChangeSceneSCBuilder {
  typedef ChangeSceneSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stage(Packets::GameStage stage) {
    fbb_.AddElement<uint8_t>(ChangeSceneSC::VT_STAGE, static_cast<uint8_t>(stage), 0);
  }
  explicit ChangeSceneSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChangeSceneSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChangeSceneSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChangeSceneSC> CreateChangeSceneSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Packets::GameStage stage = Packets::GameStage_NONE) {
  ChangeSceneSCBuilder builder_(_fbb);
  builder_.add_stage(stage);
  return builder_.Finish();
}

struct GameEndSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameEndSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINNER = 4
  };
  Packets::PlayerRole winner() const {
    return static_cast<Packets::PlayerRole>(GetField<uint8_t>(VT_WINNER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WINNER, 1) &&
           verifier.EndTable();
  }
};

struct GameEndSCBuilder {
  typedef GameEndSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_winner(Packets::PlayerRole winner) {
    fbb_.AddElement<uint8_t>(GameEndSC::VT_WINNER, static_cast<uint8_t>(winner), 0);
  }
  explicit GameEndSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameEndSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameEndSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameEndSC> CreateGameEndSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Packets::PlayerRole winner = Packets::PlayerRole_NONE) {
  GameEndSCBuilder builder_(_fbb);
  builder_.add_winner(winner);
  return builder_.Finish();
}

struct PlayerExitSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerExitSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           verifier.EndTable();
  }
};

struct PlayerExitSCBuilder {
  typedef PlayerExitSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerExitSC::VT_PLAYERID, playerId, 0);
  }
  explicit PlayerExitSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerExitSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerExitSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerExitSC> CreatePlayerExitSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0) {
  PlayerExitSCBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
struct PlayerExitCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerExitCSBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerExitCSBuilder {
  typedef PlayerExitCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerExitCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerExitCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerExitCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerExitCS> CreatePlayerExitCS(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerExitCSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerEnterInGame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerEnterInGameBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerEnterInGameBuilder {
  typedef PlayerEnterInGame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerEnterInGameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerEnterInGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerEnterInGame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerEnterInGame> CreatePlayerEnterInGame(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerEnterInGameBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerReadyInLobbyCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerReadyInLobbyCSBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerReadyInLobbyCSBuilder {
  typedef PlayerReadyInLobbyCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerReadyInLobbyCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerReadyInLobbyCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerReadyInLobbyCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerReadyInLobbyCS> CreatePlayerReadyInLobbyCS(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerReadyInLobbyCSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerCancelReadyCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerCancelReadyCSBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerCancelReadyCSBuilder {
  typedef PlayerCancelReadyCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerCancelReadyCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerCancelReadyCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerCancelReadyCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerCancelReadyCS> CreatePlayerCancelReadyCS(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerCancelReadyCSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerEnterInLobbyCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerEnterInLobbyCSBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerEnterInLobbyCSBuilder {
  typedef PlayerEnterInLobbyCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerEnterInLobbyCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerEnterInLobbyCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerEnterInLobbyCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerEnterInLobbyCS> CreatePlayerEnterInLobbyCS(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerEnterInLobbyCSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerInputCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInputCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_DOWN = 6
  };
  uint8_t key() const {
    return GetField<uint8_t>(VT_KEY, 0);
  }
  bool down() const {
    return GetField<uint8_t>(VT_DOWN, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOWN, 1) &&
           verifier.EndTable();
  }
};

struct PlayerInputCSBuilder {
  typedef PlayerInputCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(uint8_t key) {
    fbb_.AddElement<uint8_t>(PlayerInputCS::VT_KEY, key, 0);
  }
  void add_down(bool down) {
    fbb_.AddElement<uint8_t>(PlayerInputCS::VT_DOWN, static_cast<uint8_t>(down), 0);
  }
  explicit PlayerInputCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInputCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInputCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInputCS> CreatePlayerInputCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t key = 0,
    bool down = false) {
  PlayerInputCSBuilder builder_(_fbb);
  builder_.add_down(down);
  builder_.add_key(key);
  return builder_.Finish();
}

struct PlayerLookCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerLookCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOOK = 4
  };
  const Packets::Vec3 *look() const {
    return GetStruct<const Packets::Vec3 *>(VT_LOOK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Packets::Vec3>(verifier, VT_LOOK, 4) &&
           verifier.EndTable();
  }
};

struct PlayerLookCSBuilder {
  typedef PlayerLookCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_look(const Packets::Vec3 *look) {
    fbb_.AddStruct(PlayerLookCS::VT_LOOK, look);
  }
  explicit PlayerLookCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerLookCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerLookCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerLookCS> CreatePlayerLookCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Packets::Vec3 *look = nullptr) {
  PlayerLookCSBuilder builder_(_fbb);
  builder_.add_look(look);
  return builder_.Finish();
}

struct PlayerSelectRoleCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerSelectRoleCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROLE = 4
  };
  Packets::PlayerRole role() const {
    return static_cast<Packets::PlayerRole>(GetField<uint8_t>(VT_ROLE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           verifier.EndTable();
  }
};

struct PlayerSelectRoleCSBuilder {
  typedef PlayerSelectRoleCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_role(Packets::PlayerRole role) {
    fbb_.AddElement<uint8_t>(PlayerSelectRoleCS::VT_ROLE, static_cast<uint8_t>(role), 0);
  }
  explicit PlayerSelectRoleCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerSelectRoleCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerSelectRoleCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerSelectRoleCS> CreatePlayerSelectRoleCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Packets::PlayerRole role = Packets::PlayerRole_NONE) {
  PlayerSelectRoleCSBuilder builder_(_fbb);
  builder_.add_role(role);
  return builder_.Finish();
}

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
struct PacketLatencyCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketLatencyCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATENCY = 4
  };
  uint64_t latency() const {
    return GetField<uint64_t>(VT_LATENCY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY, 8) &&
           verifier.EndTable();
  }
};

struct PacketLatencyCSBuilder {
  typedef PacketLatencyCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latency(uint64_t latency) {
    fbb_.AddElement<uint64_t>(PacketLatencyCS::VT_LATENCY, latency, 0);
  }
  explicit PacketLatencyCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketLatencyCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketLatencyCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketLatencyCS> CreatePacketLatencyCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t latency = 0) {
  PacketLatencyCSBuilder builder_(_fbb);
  builder_.add_latency(latency);
  return builder_.Finish();
}

struct PacketLatencySC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketLatencySCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATENCY = 4
  };
  uint64_t latency() const {
    return GetField<uint64_t>(VT_LATENCY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY, 8) &&
           verifier.EndTable();
  }
};

struct PacketLatencySCBuilder {
  typedef PacketLatencySC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latency(uint64_t latency) {
    fbb_.AddElement<uint64_t>(PacketLatencySC::VT_LATENCY, latency, 0);
  }
  explicit PacketLatencySCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketLatencySC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketLatencySC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketLatencySC> CreatePacketLatencySC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t latency = 0) {
  PacketLatencySCBuilder builder_(_fbb);
  builder_.add_latency(latency);
  return builder_.Finish();
}

}  // namespace Packets

#endif  // FLATBUFFERS_GENERATED_NETWORKS_PACKETS_H_
