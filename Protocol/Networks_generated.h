// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKS_PACKETS_H_
#define FLATBUFFERS_GENERATED_NETWORKS_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "BaseStructures_generated.h"
#include "Enums_generated.h"

namespace Packets {

struct ProtocolVersionSC;
struct ProtocolVersionSCBuilder;

struct NotifyIdSC;
struct NotifyIdSCBuilder;

struct PlayerExitSC;
struct PlayerExitSCBuilder;

struct PlayerInput;
struct PlayerInputBuilder;

struct PlayerExitCS;
struct PlayerExitCSBuilder;

struct PlayerEnterInGame;
struct PlayerEnterInGameBuilder;

struct PlayerInputCS;
struct PlayerInputCSBuilder;

struct PlayerLookCS;
struct PlayerLookCSBuilder;

struct PlayerSelectWeaponCS;
struct PlayerSelectWeaponCSBuilder;

struct PlayerSelectRoleCS;
struct PlayerSelectRoleCSBuilder;

struct PacketLatencyCS;
struct PacketLatencyCSBuilder;

struct PacketLatencySC;
struct PacketLatencySCBuilder;

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
struct ProtocolVersionSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProtocolVersionSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAJOR = 4,
    VT_MINOR = 6
  };
  uint8_t major() const {
    return GetField<uint8_t>(VT_MAJOR, 2);
  }
  uint8_t minor() const {
    return GetField<uint8_t>(VT_MINOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_MINOR, 1) &&
           verifier.EndTable();
  }
};

struct ProtocolVersionSCBuilder {
  typedef ProtocolVersionSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_major(uint8_t major) {
    fbb_.AddElement<uint8_t>(ProtocolVersionSC::VT_MAJOR, major, 2);
  }
  void add_minor(uint8_t minor) {
    fbb_.AddElement<uint8_t>(ProtocolVersionSC::VT_MINOR, minor, 0);
  }
  explicit ProtocolVersionSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProtocolVersionSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProtocolVersionSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProtocolVersionSC> CreateProtocolVersionSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t major = 2,
    uint8_t minor = 0) {
  ProtocolVersionSCBuilder builder_(_fbb);
  builder_.add_minor(minor);
  builder_.add_major(major);
  return builder_.Finish();
}

struct NotifyIdSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyIdSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           verifier.EndTable();
  }
};

struct NotifyIdSCBuilder {
  typedef NotifyIdSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(NotifyIdSC::VT_PLAYERID, playerId, 0);
  }
  explicit NotifyIdSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyIdSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyIdSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyIdSC> CreateNotifyIdSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0) {
  NotifyIdSCBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

struct PlayerExitSC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerExitSCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID, 1) &&
           verifier.EndTable();
  }
};

struct PlayerExitSCBuilder {
  typedef PlayerExitSC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerExitSC::VT_PLAYERID, playerId, 0);
  }
  explicit PlayerExitSCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerExitSC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerExitSC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerExitSC> CreatePlayerExitSC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0) {
  PlayerExitSCBuilder builder_(_fbb);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
struct PlayerInput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_DOWN = 6
  };
  uint8_t key() const {
    return GetField<uint8_t>(VT_KEY, 0);
  }
  bool down() const {
    return GetField<uint8_t>(VT_DOWN, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOWN, 1) &&
           verifier.EndTable();
  }
};

struct PlayerInputBuilder {
  typedef PlayerInput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(uint8_t key) {
    fbb_.AddElement<uint8_t>(PlayerInput::VT_KEY, key, 0);
  }
  void add_down(bool down) {
    fbb_.AddElement<uint8_t>(PlayerInput::VT_DOWN, static_cast<uint8_t>(down), 0);
  }
  explicit PlayerInputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInput> CreatePlayerInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t key = 0,
    bool down = false) {
  PlayerInputBuilder builder_(_fbb);
  builder_.add_down(down);
  builder_.add_key(key);
  return builder_.Finish();
}

struct PlayerExitCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerExitCSBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerExitCSBuilder {
  typedef PlayerExitCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerExitCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerExitCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerExitCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerExitCS> CreatePlayerExitCS(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerExitCSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerEnterInGame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerEnterInGameBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PlayerEnterInGameBuilder {
  typedef PlayerEnterInGame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PlayerEnterInGameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerEnterInGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerEnterInGame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerEnterInGame> CreatePlayerEnterInGame(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PlayerEnterInGameBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PlayerInputCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInputCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_DOWN = 6
  };
  uint8_t key() const {
    return GetField<uint8_t>(VT_KEY, 0);
  }
  bool down() const {
    return GetField<uint8_t>(VT_DOWN, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOWN, 1) &&
           verifier.EndTable();
  }
};

struct PlayerInputCSBuilder {
  typedef PlayerInputCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(uint8_t key) {
    fbb_.AddElement<uint8_t>(PlayerInputCS::VT_KEY, key, 0);
  }
  void add_down(bool down) {
    fbb_.AddElement<uint8_t>(PlayerInputCS::VT_DOWN, static_cast<uint8_t>(down), 0);
  }
  explicit PlayerInputCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInputCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInputCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInputCS> CreatePlayerInputCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t key = 0,
    bool down = false) {
  PlayerInputCSBuilder builder_(_fbb);
  builder_.add_down(down);
  builder_.add_key(key);
  return builder_.Finish();
}

struct PlayerLookCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerLookCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOOK = 4
  };
  const Packets::Vec3 *look() const {
    return GetStruct<const Packets::Vec3 *>(VT_LOOK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Packets::Vec3>(verifier, VT_LOOK, 4) &&
           verifier.EndTable();
  }
};

struct PlayerLookCSBuilder {
  typedef PlayerLookCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_look(const Packets::Vec3 *look) {
    fbb_.AddStruct(PlayerLookCS::VT_LOOK, look);
  }
  explicit PlayerLookCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerLookCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerLookCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerLookCS> CreatePlayerLookCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Packets::Vec3 *look = nullptr) {
  PlayerLookCSBuilder builder_(_fbb);
  builder_.add_look(look);
  return builder_.Finish();
}

struct PlayerSelectWeaponCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerSelectWeaponCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEAPON = 4
  };
  Packets::Weapon weapon() const {
    return static_cast<Packets::Weapon>(GetField<uint8_t>(VT_WEAPON, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON, 1) &&
           verifier.EndTable();
  }
};

struct PlayerSelectWeaponCSBuilder {
  typedef PlayerSelectWeaponCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_weapon(Packets::Weapon weapon) {
    fbb_.AddElement<uint8_t>(PlayerSelectWeaponCS::VT_WEAPON, static_cast<uint8_t>(weapon), 0);
  }
  explicit PlayerSelectWeaponCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerSelectWeaponCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerSelectWeaponCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerSelectWeaponCS> CreatePlayerSelectWeaponCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Packets::Weapon weapon = Packets::Weapon_SWORD) {
  PlayerSelectWeaponCSBuilder builder_(_fbb);
  builder_.add_weapon(weapon);
  return builder_.Finish();
}

struct PlayerSelectRoleCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerSelectRoleCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROLE = 4
  };
  Packets::PlayerRole role() const {
    return static_cast<Packets::PlayerRole>(GetField<uint8_t>(VT_ROLE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           verifier.EndTable();
  }
};

struct PlayerSelectRoleCSBuilder {
  typedef PlayerSelectRoleCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_role(Packets::PlayerRole role) {
    fbb_.AddElement<uint8_t>(PlayerSelectRoleCS::VT_ROLE, static_cast<uint8_t>(role), 0);
  }
  explicit PlayerSelectRoleCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerSelectRoleCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerSelectRoleCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerSelectRoleCS> CreatePlayerSelectRoleCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Packets::PlayerRole role = Packets::PlayerRole_HUMAN) {
  PlayerSelectRoleCSBuilder builder_(_fbb);
  builder_.add_role(role);
  return builder_.Finish();
}

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
struct PacketLatencyCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketLatencyCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATENCY = 4
  };
  uint64_t latency() const {
    return GetField<uint64_t>(VT_LATENCY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY, 8) &&
           verifier.EndTable();
  }
};

struct PacketLatencyCSBuilder {
  typedef PacketLatencyCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latency(uint64_t latency) {
    fbb_.AddElement<uint64_t>(PacketLatencyCS::VT_LATENCY, latency, 0);
  }
  explicit PacketLatencyCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketLatencyCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketLatencyCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketLatencyCS> CreatePacketLatencyCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t latency = 0) {
  PacketLatencyCSBuilder builder_(_fbb);
  builder_.add_latency(latency);
  return builder_.Finish();
}

struct PacketLatencySC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketLatencySCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATENCY = 4
  };
  uint64_t latency() const {
    return GetField<uint64_t>(VT_LATENCY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY, 8) &&
           verifier.EndTable();
  }
};

struct PacketLatencySCBuilder {
  typedef PacketLatencySC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latency(uint64_t latency) {
    fbb_.AddElement<uint64_t>(PacketLatencySC::VT_LATENCY, latency, 0);
  }
  explicit PacketLatencySCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketLatencySC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketLatencySC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketLatencySC> CreatePacketLatencySC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t latency = 0) {
  PacketLatencySCBuilder builder_(_fbb);
  builder_.add_latency(latency);
  return builder_.Finish();
}

}  // namespace Packets

#endif  // FLATBUFFERS_GENERATED_NETWORKS_PACKETS_H_
