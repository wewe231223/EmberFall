// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PACKETHEADER_PACKETS_H_
#define FLATBUFFERS_GENERATED_PACKETHEADER_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "BaseStructures_generated.h"
#include "Enums_generated.h"

namespace Packets {

struct PacketHeaderSC;

struct PacketHeaderCS;

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) PacketHeaderSC FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t size_;
  uint8_t type_;
  int8_t padding0__;

 public:
  PacketHeaderSC()
      : size_(0),
        type_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PacketHeaderSC(int16_t _size, uint8_t _type)
      : size_(::flatbuffers::EndianScalar(_size)),
        type_(::flatbuffers::EndianScalar(_type)),
        padding0__(0) {
    (void)padding0__;
  }
  int16_t size() const {
    return ::flatbuffers::EndianScalar(size_);
  }
  uint8_t type() const {
    return ::flatbuffers::EndianScalar(type_);
  }
};
FLATBUFFERS_STRUCT_END(PacketHeaderSC, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) PacketHeaderCS FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t size_;
  uint8_t type_;
  uint8_t id_;

 public:
  PacketHeaderCS()
      : size_(0),
        type_(0),
        id_(0) {
  }
  PacketHeaderCS(int16_t _size, uint8_t _type, uint8_t _id)
      : size_(::flatbuffers::EndianScalar(_size)),
        type_(::flatbuffers::EndianScalar(_type)),
        id_(::flatbuffers::EndianScalar(_id)) {
  }
  int16_t size() const {
    return ::flatbuffers::EndianScalar(size_);
  }
  uint8_t type() const {
    return ::flatbuffers::EndianScalar(type_);
  }
  uint8_t id() const {
    return ::flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(PacketHeaderCS, 4);

}  // namespace Packets

#endif  // FLATBUFFERS_GENERATED_PACKETHEADER_PACKETS_H_
