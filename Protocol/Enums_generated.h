// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUMS_PACKETS_H_
#define FLATBUFFERS_GENERATED_ENUMS_PACKETS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

namespace Packets {

enum PacketTypes : uint8_t {
  PacketTypes_PT_PROTOCOL_VERSION_SC = 128,
  PacketTypes_PT_NOTIFY_ID_SC = 129,
  PacketTypes_PT_PLAYER_EXIT_SC = 130,
  PacketTypes_PT_PLAYER_APPEARED_SC = 131,
  PacketTypes_PT_PLAYER_DISAPPEARED_SC = 132,
  PacketTypes_PT_MONSTER_ = 133,
  PacketTypes_MIN = PacketTypes_PT_PROTOCOL_VERSION_SC,
  PacketTypes_MAX = PacketTypes_PT_MONSTER_
};

inline const PacketTypes (&EnumValuesPacketTypes())[6] {
  static const PacketTypes values[] = {
    PacketTypes_PT_PROTOCOL_VERSION_SC,
    PacketTypes_PT_NOTIFY_ID_SC,
    PacketTypes_PT_PLAYER_EXIT_SC,
    PacketTypes_PT_PLAYER_APPEARED_SC,
    PacketTypes_PT_PLAYER_DISAPPEARED_SC,
    PacketTypes_PT_MONSTER_
  };
  return values;
}

inline const char * const *EnumNamesPacketTypes() {
  static const char * const names[7] = {
    "PT_PROTOCOL_VERSION_SC",
    "PT_NOTIFY_ID_SC",
    "PT_PLAYER_EXIT_SC",
    "PT_PLAYER_APPEARED_SC",
    "PT_PLAYER_DISAPPEARED_SC",
    "PT_MONSTER_",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketTypes(PacketTypes e) {
  if (::flatbuffers::IsOutRange(e, PacketTypes_PT_PROTOCOL_VERSION_SC, PacketTypes_PT_MONSTER_)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(PacketTypes_PT_PROTOCOL_VERSION_SC);
  return EnumNamesPacketTypes()[index];
}

enum AnimationState : uint8_t {
  AnimationState_IDLE = 0,
  AnimationState_MOVE_FORWARD = 1,
  AnimationState_MOVE_BACKWARD = 2,
  AnimationState_MOVE_LEFT = 3,
  AnimationState_MOVE_RIGHT = 4,
  AnimationState_JUMP = 5,
  AnimationState_ATTACKED = 6,
  AnimationState_ATTACK = 7,
  AnimationState_INTERACTION = 8,
  AnimationState_DEAD = 9,
  AnimationState_MIN = AnimationState_IDLE,
  AnimationState_MAX = AnimationState_DEAD
};

inline const AnimationState (&EnumValuesAnimationState())[10] {
  static const AnimationState values[] = {
    AnimationState_IDLE,
    AnimationState_MOVE_FORWARD,
    AnimationState_MOVE_BACKWARD,
    AnimationState_MOVE_LEFT,
    AnimationState_MOVE_RIGHT,
    AnimationState_JUMP,
    AnimationState_ATTACKED,
    AnimationState_ATTACK,
    AnimationState_INTERACTION,
    AnimationState_DEAD
  };
  return values;
}

inline const char * const *EnumNamesAnimationState() {
  static const char * const names[11] = {
    "IDLE",
    "MOVE_FORWARD",
    "MOVE_BACKWARD",
    "MOVE_LEFT",
    "MOVE_RIGHT",
    "JUMP",
    "ATTACKED",
    "ATTACK",
    "INTERACTION",
    "DEAD",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnimationState(AnimationState e) {
  if (::flatbuffers::IsOutRange(e, AnimationState_IDLE, AnimationState_DEAD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnimationState()[index];
}

enum Weapon : uint8_t {
  Weapon_SWORD = 0,
  Weapon_BOW = 1,
  Weapon_SPEAR = 2,
  Weapon_STAFF = 3,
  Weapon_MIN = Weapon_SWORD,
  Weapon_MAX = Weapon_STAFF
};

inline const Weapon (&EnumValuesWeapon())[4] {
  static const Weapon values[] = {
    Weapon_SWORD,
    Weapon_BOW,
    Weapon_SPEAR,
    Weapon_STAFF
  };
  return values;
}

inline const char * const *EnumNamesWeapon() {
  static const char * const names[5] = {
    "SWORD",
    "BOW",
    "SPEAR",
    "STAFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeapon(Weapon e) {
  if (::flatbuffers::IsOutRange(e, Weapon_SWORD, Weapon_STAFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeapon()[index];
}

enum ItemType : uint8_t {
  ItemType_POTION = 0,
  ItemType_CROSS = 1,
  ItemType_HOLY_WATER = 2,
  ItemType_MIN = ItemType_POTION,
  ItemType_MAX = ItemType_HOLY_WATER
};

inline const ItemType (&EnumValuesItemType())[3] {
  static const ItemType values[] = {
    ItemType_POTION,
    ItemType_CROSS,
    ItemType_HOLY_WATER
  };
  return values;
}

inline const char * const *EnumNamesItemType() {
  static const char * const names[4] = {
    "POTION",
    "CROSS",
    "HOLY_WATER",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemType(ItemType e) {
  if (::flatbuffers::IsOutRange(e, ItemType_POTION, ItemType_HOLY_WATER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemType()[index];
}

enum ProjectileTypes : uint8_t {
  ProjectileTypes_ARROW = 0,
  ProjectileTypes_MIN = ProjectileTypes_ARROW,
  ProjectileTypes_MAX = ProjectileTypes_ARROW
};

inline const ProjectileTypes (&EnumValuesProjectileTypes())[1] {
  static const ProjectileTypes values[] = {
    ProjectileTypes_ARROW
  };
  return values;
}

inline const char * const *EnumNamesProjectileTypes() {
  static const char * const names[2] = {
    "ARROW",
    nullptr
  };
  return names;
}

inline const char *EnumNameProjectileTypes(ProjectileTypes e) {
  if (::flatbuffers::IsOutRange(e, ProjectileTypes_ARROW, ProjectileTypes_ARROW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProjectileTypes()[index];
}

}  // namespace Packets

#endif  // FLATBUFFERS_GENERATED_ENUMS_PACKETS_H_
